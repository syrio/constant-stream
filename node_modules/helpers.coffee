EventEmitter = require('events').EventEmitter
irc = require('irc')

class StreamIrc
  constructor: (server, user, cb) ->
    @client = new irc.Client(server, user, {userName: user})
    @client.on 'connect', cb if cb?
    @client.on 'error', cb if cb?

  join: (channel, cb) ->
    channel = "##{channel}" unless channel[0] == '#'
    @client.addListener("message#{channel}", cb)
    @client.join("#{channel}")
  leave: (channel, cb) ->
    channel = "##{channel}" unless channel[0] == '#'
    @client.part("#{channel}")
  names: (channel) ->
    channel = "##{channel}" unless channel[0] == '#'    
    @client.send('NAMES', "#{channel}")
  say: (channel, message) ->
    @client.say(channel, message)
  on: (event, handler) ->
    @client.on event, handler
    this
  disconnect:  ->
    @client.disconnect()
  private: (handler) ->
    @client.on 'pm', (from, message) ->
      handler from, message
  members: (handler) ->
    @client.on 'names', (channel, names) ->
      channel = channel.replace('#', '')
      members = for own name, symbol of names
        "#{symbol}#{name}" unless name == ''
      handler channel, ({name : member} for member in members when member?)
  topic: (handler) ->
    @client.on 'topic', (channel, topic) ->
      channel = channel.replace('#', '')
      handler channel, topic
  new_member: (watched_channel, handler) ->
    watched_channel = watched_channel.replace('#', '')
    # strip for safety in comparison as watched_channel is provided by caller
    @client.on "join##{watched_channel}", (new_member_name) ->
      # strip for safety in comparison
      handler(watched_channel, { name : new_member_name })
  leaving_member: (watched_channel, handler) ->
    # strip for safety in comparison as watched_channel is provided by caller
    watched_channel = watched_channel.replace('#', '')
    @client.on 'part', (channel, leaving_member_name, leaving_reason) ->
      # again, strip for safety in comparison as channels are returned by the server
      if watched_channel == channel.replace('#', '')
        handler(watched_channel, { name : leaving_member_name })
  changing_member: (watched_channel, handler) ->
    # strip for safety in comparison as watched_channel is provided by caller
    watched_channel = watched_channel.replace('#', '')
    @client.on 'nick', (old_name, new_name, channels) ->
      # again, strip for safety in comparison as channels are returned by the server
      for channel in channels
        if watched_channel == channel.replace('#', '')
          handler(watched_channel, old_name, new_name)
          return
    
class StreamStorage
  constructor: ->
    global.R = require('redis').createClient() unless R? and not R.closing
  lstore: (key, value) ->
    R.rpush key, value
  sstore: (key, value) ->
    R.sadd key, value
  get: (key, cb) ->
    R.type key, (err, type) ->
      switch type
        when 'list' then  R.lrange key, 0, -1, cb
        when 'set'  then  R.smembers key, cb
  remove: (key, value) ->
    return R.del key unless value?
    R.type key, (err, type) ->
      switch type
        when 'list' then  R.lrem key, 0, value
        when 'set'  then  R.srem key, value
  ismember: (key, value, cb) ->
    R.sismember(key, value, cb)
  keys: (keys, cb) ->
    R.keys(keys, cb)
    
class DataObserver extends EventEmitter
  constructor: (observations, @session) ->
    for own name, handlers of observations
      for handler in handlers
        @on name, handler
  isCurrentSession: (session) ->
    session.id == @session.id            
  observedNewData: (session, new_data) =>
    @emit 'newData', session, new_data if @isCurrentSession(session)
  observedNewPrivateData: (session, new_private_data) =>
    @emit 'newPrivateData', session, new_private_data if @isCurrentSession(session)
    
class ChannelObserver extends EventEmitter
  constructor: (observations, @session) ->
    for own name, handlers of observations
      for handler in handlers
        @on name, handler
  isCurrentSession: (session) ->
    session.id == @session.id        
  observedNewMember: (session, new_member) =>
    @emit 'newMember', new_member if @isCurrentSession(session)
  observedLeavingMember: (session, leaving_member) =>
    @emit 'leavingMember', leaving_member if @isCurrentSession(session)
  observedChangingMember: (session, changing_member) =>
    @emit 'changingMember', changing_member if @isCurrentSession(session)    
  observedCurrentTopic: (session, current_topic) =>
    @emit 'currentTopic', current_topic if @isCurrentSession(session)
  observedCurrentMembers: (session, current_members) =>
    console.log 'got members list, @session, session, current_members'
    @emit 'currentMembers', current_members if @isCurrentSession(session)


class SessionObserver
  constructor: (@manager, @session) ->
    @observeSessionDisconnect()
    @observeSessionConnect()
    @observeSessionChannelSubscription()
    @observeSessionChannelUnsubscription()    
    @observeSessionHeartbeat()
  
  isCurrentSession: (session) ->
    session.id == @session.id
  observeSessionDisconnect:  ->
    SS.events.on('client:disconnect', (session) => @manager.handleDisconnect(session) if @isCurrentSession(session))
  observeSessionConnect: ->
    SS.events.on('client:init', (session) => @manager.handleConnect(session) if @isCurrentSession(session))  
  observeSessionChannelSubscription: ->
    SS.events.on('channel:subscribe', (session, channel) => @manager.handleSubscribe(session, channel) if @isCurrentSession(session))    
  observeSessionChannelUnsubscription: ->
    SS.events.on('channel:unsubscribe', (session, channel) => @manager.handleUnsubscribe(session, channel) if @isCurrentSession(session))
    
  observeSessionHeartbeat: ->
    
    # taken from SocketStream lib/backend/users_online.coffee
    minuteCode = (mins_ago = 0) ->
      t = Math.ceil(Number(new Date() / 1000))
      t -= (t % 60)
      t -= (mins_ago * 60)
    every = (seconds, cb) -> setInterval cb, seconds*1000
    manager = @manager
    
    return unless SS.config?.offline_expire?
    
    every SS.config.offline_expire.interval, ->
      # cut the heartbeat to granularity to once in 1000 seconds and have it check for sessions
      # that haven't sent a heartbeat in 24 hours
      heartbeat_period = parseInt(minuteCode(SS.config.offline_expire.timeout) / 1000)
      manager.handleHeartbeat heartbeat_period 

class OnlineDataManager
  constructor: ->
  handleNewData: (session, new_data) ->
    SS.publish.user session.id, "#{new_data.channel}:newMessage", new_data.message
  handleNewPrivateData: (session, new_private_data) ->
    SS.publish.user session.id, 'newPrivateMessage', new_private_data.message
    
class OfflineDataManager
  constructor: (@storage) ->
  handleNewData: (session, new_data) =>
    @storage.ismember 'offline:sessions', session.id, (err, session_member) =>
        if session_member
          @storage.ismember "session:#{session.id}:channels", new_data.channel, (err, channel_member) =>
            if channel_member
              @storage.lstore("offline:#{session.id}:#{new_data.channel}:messages", JSON.stringify(new_data.message))
  handleNewPrivateData: (session, new_private_data) =>
    @storage.ismember 'offline:sessions', session.id, (err, session_member) =>
        if session_member
          @storage.lstore("offline:#{session.id}:private", JSON.stringify(new_private_data.message))
    
class OnlineChannelManager
  constructor: ->
  # Could refactor to one general publish method, but this is makes things a bit clearer
  handleNewMember: (new_member) ->
    SS.publish.channel new_member.channel, "#{new_member.channel}:newMember", new_member.member
  handleLeavingMember: (leaving_member) ->
    SS.publish.channel leaving_member.channel, "#{leaving_member.channel}:leavingMember", leaving_member.member  
  handleChangingMember: (changing_member) ->
    SS.publish.channel changing_member.channel, "#{changing_member.channel}:changingMember", changing_member.member  
  handleCurrentTopic: (current_topic) ->
    SS.publish.channel current_topic.channel, "#{current_topic.channel}:currentTopic", current_topic.topic
  handleCurrentMembers: (current_members) ->
    SS.publish.channel current_members.channel, "#{current_members.channel}:currentMembers", current_members.members

    
class OfflineChannelManager
  constructor: (@storage) ->
  handleNewMember: (new_member) ->


class SessionManager extends EventEmitter
  constructor: (@storage) ->
    @on 'reconnect', @handleReconnect
    @on 'timeout', @handleTimeout
    
  handleDisconnect: (session) =>
    @storage.sstore('offline:sessions', session.id)
    @emit 'disconnect', session
    
  handleConnect: (session) =>
    @storage.ismember 'offline:sessions', session.id, (err, ismember) =>
      @emit 'reconnect', session if not err and ismember
      
  handleReconnect: (session) =>
    # update SocketStream that the user reconnected
    SS.users?.online.add(session.user_id)
    # send all stored channel messages
    for channel in session.channels
      do (channel) =>
        @storage.get "offline:#{session.id}:#{channel}:messages", (err, messages) =>
          for message in messages
            SS.publish.user session.user_id, "#{channel}:newMessage", JSON.parse(message)
          @storage.remove("offline:#{session.id}:#{channel}:messages")
        
    # send all stored private messages
    @storage.get "offline:#{session.id}:private", (err, messages) =>
      for message in messages
        SS.publish.user session.id, 'newPrivateMessage', JSON.parse(message)        
      @storage.remove "offline:#{session.id}:private"
    
    @storage.remove 'offline:sessions', session.id
    
  handleSubscribe: (session, channel) =>
    @storage.sstore("session:#{session.id}:channels", channel)
    @emit 'subscribe', session
    
  handleUnsubscribe: (session, channel) =>
    @storage.remove("session:#{session.id}:channels", channel)
    @emit 'unsubscribe', session
    
  handleHeartbeat: (checked_period) =>
    # check if we have any overdue sessions
    sessions_within_checked_period = "#{SS.config.redis.key_prefix}:online:at:#{checked_period}*"
    @storage.keys sessions_within_checked_period, (err, overdue_heartbeats) =>
      for heartbeat in overdue_heartbeats
        @storage.get heartbeat, (err, overdue_sessions_ids) =>
          for session_id in overdue_sessions_ids
            # emit a timeout event for every overdue session, provide session_id
            @emit 'timeout', session_id
          @storage.remove heartbeat
    @emit 'hearbeat', checked_period
    
  handleTimeout: (session_id) =>
    @storage.remove("offline:sessions", session_id)
    @storage.get "session:#{session_id}:channels", (err, channels) =>
      for channel in channels
        @storage.remove("offline:#{session_id}:#{channel}:messages")
      @storage.remove("session:#{session_id}:channels")
    
exports.StreamIrc = StreamIrc
exports.StreamStorage = StreamStorage
exports.DataObserver = DataObserver    
exports.ChannelObserver = ChannelObserver
exports.SessionObserver = SessionObserver
exports.SessionManager = SessionManager
exports.OnlineDataManager = OnlineDataManager
exports.OfflineDataManager = OfflineDataManager
exports.OnlineChannelManager = OnlineChannelManager
exports.OfflineChannelManager = OfflineChannelManager

