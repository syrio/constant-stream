EventEmitter = require('events').EventEmitter
irc = require('irc')

class StreamIrc
  constructor: (server, user, cb) ->
    @channels = {}    
    @client = new irc.Client(server, user, {userName: user})
    @client.on 'connect', cb if cb?
    @client.on 'error', cb if cb?

  join: (channel, cb) ->
    channel = "##{channel}" unless channel[0] == '#'
    @client.addListener("message#{channel}", cb)
    @client.join("#{channel}")

    @channels[channel] = {}
    # continue asking for names every 10 seconds as some servers simply don't send them when overloaded
    @channels[channel].names_fetcher_id = setInterval((=> 
      @names(channel) 
    ), 10000)

  leave: (channel, cb) ->
    channel = "##{channel}" unless channel[0] == '#'
    @client.part("#{channel}")
    #TODO: Remove all of the channel listeners (part, nick)
    @client.removeAllListeners("join#{channel}")
    @client.removeAllListeners("message#{channel}")
    
  names: (channel) ->
    channel = "##{channel}" unless channel[0] == '#'    
    @client.send('NAMES', "#{channel}")
    
  say: (channel, message) ->
    @client.say(channel, message)
    
  on: (event, handler) ->
    @client.on event, handler
    this
    
  disconnect:  ->
    @client.disconnect()
    
  private: (handler) ->
    @client.on 'pm', (from, message) ->
      handler from, message
      
  members: (handler) ->
    @client.on 'names', (channel, names) =>
      channel = channel.replace('#', '')
      members = for own name, symbol of names
        "#{symbol}#{name}" unless name == ''
      handler channel, ({name : member} for member in members when member?)
      
      # got names from the server, we can clear the the names fetcher set in @join
      names_fetcher_id = @channels["##{channel}"]?.names_fetcher_id
      if names_fetcher_id?
        clearInterval names_fetcher_id
        delete @channels["##{channel}"].names_fetcher_id
        
  topic: (handler) ->
    @client.on 'topic', (channel, topic) ->
      channel = channel.replace('#', '')
      handler channel, topic

  new_member: (watched_channel, handler) ->
    watched_channel = watched_channel.replace('#', '')
    # strip for safety in comparison as watched_channel is provided by caller
    @client.on "join##{watched_channel}", (new_member_name) ->
      # strip for safety in comparison
      handler(watched_channel, { name : new_member_name })

  leaving_member: (watched_channel, handler) ->
    # strip for safety in comparison as watched_channel is provided by caller
    watched_channel = watched_channel.replace('#', '')
    @client.on 'part', (channel, leaving_member_name, leaving_reason) ->
      # again, strip for safety in comparison as channels are returned by the server
      if watched_channel == channel.replace('#', '')
        handler(watched_channel, { name : leaving_member_name })

  changing_member: (watched_channel, handler) ->
    # strip for safety in comparison as watched_channel is provided by caller
    watched_channel = watched_channel.replace('#', '')
    @client.on 'nick', (old_name, new_name, channels) ->
      # again, strip for safety in comparison as channels are returned by the server
      for channel in channels
        if watched_channel == channel.replace('#', '')
          handler(watched_channel, old_name, new_name)
          return
    
class StreamStorage
  constructor: ->
    global.R = require('redis').createClient() unless R? and not R.closing
  lstore: (key, value) ->
    R.rpush key, value
  sstore: (key, value) ->
    R.sadd key, value
  zstore: (key, score, value) ->
    R.zadd key, score, value
  store: (key, value) ->
    R.set key, value
  get: (key, cb) ->
    R.type key, (err, type) ->
      switch type
        when 'list' then  R.lrange key, 0, -1, cb
        when 'set'  then  R.smembers key, cb
        when 'string' then R.get key, cb
  remove: (key, value) ->
    return R.del key unless value?
    R.type key, (err, type) ->
      switch type
        when 'list' then  R.lrem key, 0, value
        when 'set'  then  R.srem key, value
        when 'zset' then  R.zrem key, value
  ismember: (key, value, cb) ->
    R.type key, (err, type) ->
      switch type
        when 'set' then R.sismember(key, value, cb)
        when 'zset' then R.zscore(key, value, (err, rank) ->
          return cb(err, null) if err
          cb(0, rank != null)
        )
  keys: (keys, cb) ->
    R.keys(keys, cb)
  range: (key, start, end, cb) ->
    R.zrangebyscore key, start, end, cb
  remrange: (key, start, end) ->
    R.zremrangebyscore key, start, end
    
class DataObserver extends EventEmitter
  constructor: (observations, @session) ->
    for own name, handlers of observations
      for handler in handlers
        @on name, handler
  isCurrentSession: (session) ->
    session.id == @session.id            
  observedNewData: (session, new_data) =>
    @emit('newData', session, new_data) if @isCurrentSession(session)
  observedNewPrivateData: (session, new_private_data) =>
    @emit('newPrivateData', session, new_private_data) if @isCurrentSession(session)
    
class ChannelObserver extends EventEmitter
  constructor: (observations, @session) ->
    for own name, handlers of observations
      for handler in handlers
        @on name, handler
  isCurrentSession: (session) ->
    session.id == @session.id        
  observedNewMember: (session, new_member) =>
    @emit('newMember', new_member) if @isCurrentSession(session)
  observedLeavingMember: (session, leaving_member) =>
    @emit('leavingMember', leaving_member) if @isCurrentSession(session)
  observedChangingMember: (session, changing_member) =>
    @emit('changingMember', changing_member) if @isCurrentSession(session)    
  observedCurrentTopic: (session, current_topic) =>
    @emit('currentTopic', current_topic) if @isCurrentSession(session)
  observedCurrentMembers: (session, current_members) =>
    @emit('currentMembers', current_members) if @isCurrentSession(session)


class SessionObserver
  constructor: (@manager, @session) ->
    @observeSessionDisconnect()
    @observeSessionConnect()
    @observeSessionChannelSubscription()
    @observeSessionChannelUnsubscription()    
    @observeSessionHeartbeat()
  
  isCurrentSession: (session) ->
    session.id == @session.id
  observeSessionDisconnect:  ->
    SS.events.on('client:disconnect', (session) => @manager.handleDisconnect(session) if @isCurrentSession(session))
  observeSessionConnect: ->
    SS.events.on('client:init', (session) => @manager.handleConnect(session) if @isCurrentSession(session))  
  observeSessionChannelSubscription: ->
    SS.events.on('channel:subscribe', (session, channel) => @manager.handleSubscribe(session, channel) if @isCurrentSession(session))    
  observeSessionChannelUnsubscription: ->
    SS.events.on('channel:unsubscribe', (session, channel) => @manager.handleUnsubscribe(session, channel) if @isCurrentSession(session))
    
  observeSessionHeartbeat: ->
    
    every = (seconds, cb) -> setInterval cb, seconds*1000
    manager = @manager
    
    return unless SS.config?.offline_expire?
    
    every SS.config.offline_expire.interval, ->
      # cut the heartbeat to granularity to once in 1000 seconds and have it check for sessions
      # that haven't sent a heartbeat in 24 hours
      
      current_ms = new Date().getTime()
      timeout_ms = (SS.config.offline_expire.timeout * 60 * 1000)
      console.log 'current', current_ms, 'day', timeout_ms
      current_ms -= timeout_ms
      period = 
        start: current_ms - 50 # sub 50 to make sure we won't miss
        end: current_ms + SS.config.offline_expire.interval*1000 + 50 # add 50 to make sure we won't miss
      console.log 'calling hearbeat', period
      manager.handleHeartbeat period

class OnlineDataManager
  constructor: ->
  handleNewData: (session, new_data) ->
    SS.publish.user session.id, "#{new_data.channel}:newMessage", new_data.message
  handleNewPrivateData: (session, new_private_data) ->
    SS.publish.user session.id, 'newPrivateMessage', new_private_data.message
    
class OfflineDataManager
  constructor: (@storage) ->
  handleNewData: (session, new_data) =>
    @storage.ismember 'offline:sessions', session.id, (err, session_member) =>
        if session_member
          @storage.ismember "session:#{session.id}:channels", new_data.channel, (err, channel_member) =>
            if channel_member
              @storage.lstore("offline:#{session.id}:#{new_data.channel}:messages", JSON.stringify(new_data.message))
  handleNewPrivateData: (session, new_private_data) =>
    @storage.ismember 'offline:sessions', session.id, (err, session_member) =>
        if session_member
          @storage.lstore("offline:#{session.id}:private", JSON.stringify(new_private_data.message))
    
class OnlineChannelManager
  constructor: ->
  # Could refactor to one general publish method, but this is makes things a bit clearer
  handleNewMember: (new_member) ->
    SS.publish.channel new_member.channel, "#{new_member.channel}:newMember", new_member.member
  handleLeavingMember: (leaving_member) ->
    SS.publish.channel leaving_member.channel, "#{leaving_member.channel}:leavingMember", leaving_member.member  
  handleChangingMember: (changing_member) ->
    SS.publish.channel changing_member.channel, "#{changing_member.channel}:changingMember", changing_member.member  
  handleCurrentTopic: (current_topic) ->
    SS.publish.channel current_topic.channel, "#{current_topic.channel}:currentTopic", current_topic.topic
  handleCurrentMembers: (current_members) ->
    SS.publish.channel current_members.channel, "#{current_members.channel}:currentMembers", current_members.members

    
class OfflineChannelManager
  constructor: (@storage) ->
  handleNewMember: (new_member) ->


class SessionManager extends EventEmitter
  constructor: (@storage) ->
    @on 'reconnect', @handleReconnect
    @on 'timeout', @handleTimeout
    
  handleDisconnect: (session) =>
    
    @storage.zstore('offline:sessions', new Date().getTime(), session.id)
    
    @emit 'disconnect', session
    
  handleConnect: (session) =>
    ###
    @storage.ismember 'offline:sessions', session.id, (err, ismember) =>
      @emit 'reconnect', session if not err and ismember
    ###  
    @storage.ismember 'offline:sessions', session.id, (err, ismember) =>
      @emit 'reconnect', session if not err and ismember
    
  handleReconnect: (session) =>
    # update SocketStream that the user reconnected
    SS.users?.online.add(session.user_id)
    # send all stored channel messages
    for channel in session.channels
      do (channel) =>
        @storage.get "offline:#{session.id}:#{channel}:messages", (err, messages) =>
          for message in messages
            SS.publish.user session.user_id, "#{channel}:newMessage", JSON.parse(message)
          @storage.remove("offline:#{session.id}:#{channel}:messages")
        
    # send all stored private messages
    @storage.get "offline:#{session.id}:private", (err, messages) =>
      for message in messages
        SS.publish.user session.id, 'newPrivateMessage', JSON.parse(message)        
      @storage.remove "offline:#{session.id}:private"
    
    @storage.remove 'offline:sessions', session.id
    
  handleSubscribe: (session, channel) =>
    @storage.sstore("session:#{session.id}:channels", channel)
    @emit 'subscribe', session
    
  handleUnsubscribe: (session, channel) =>
    @storage.remove("session:#{session.id}:channels", channel)
    @emit 'unsubscribe', session
    
  handleHeartbeat: (checked_period) =>
    # check if we have any overdue sessions
    @storage.range 'offline:sessions', checked_period.start, checked_period.end, (err, overdue_sessions) =>
      for session in overdue_sessions
        @emit 'timeout', session
    
    @emit 'hearbeat', checked_period
    
  handleTimeout: (session_id) =>
    
    @storage.remove "offline:sessions", session_id
    
    @storage.get "session:#{session_id}:channels", (err, channels) =>
      for channel in channels
        @storage.remove("offline:#{session_id}:#{channel}:messages")
      @storage.remove("session:#{session_id}:channels")
    
exports.StreamIrc = StreamIrc
exports.StreamStorage = StreamStorage
exports.DataObserver = DataObserver    
exports.ChannelObserver = ChannelObserver
exports.SessionObserver = SessionObserver
exports.SessionManager = SessionManager
exports.OnlineDataManager = OnlineDataManager
exports.OfflineDataManager = OfflineDataManager
exports.OnlineChannelManager = OnlineChannelManager
exports.OfflineChannelManager = OfflineChannelManager

